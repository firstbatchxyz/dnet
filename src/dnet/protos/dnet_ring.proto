syntax = "proto3";

package dnetring;

// The service for running distributed inference over a ring
service DnetRingService {
    // Send activation data to the next node in the ring
    rpc SendActivation(ActivationRequest) returns (ActivationResponse);

    // Health check for node status
    rpc HealthCheck(HealthRequest) returns (HealthResponse);

    // Reset LLM Cache
    rpc ResetCache (ResetCacheRequest) returns (ResetCacheResponse) {}

    // Measure latency between nodes
    rpc MeasureLatency (LatencyMeasureRequest) returns (LatencyMeasureResponse) {}

    // Streaming activations per request (optional, bidi)
    rpc StreamActivations(stream ActivationFrame) returns (stream StreamAck);
}

message Activation {
  bytes data = 1;
  int32 batch_size = 2;
  repeated int32 shape = 3;
  string dtype = 4;
  int32 layer_id = 5;
}

message ActivationRequest {
    string nonce = 1;
    Activation activation = 2;
    int64 timestamp = 3;
    string node_origin = 4;
    string callback_url = 5;
    float rx_enq_t = 6;
    float tx_enq_prev_t = 7;
    float rx_inflight_t = 8;
}

// Response message for activation sending
message ActivationResponse {
    bool success = 1;             // Whether the activation was processed successfully
    string message = 2;           // Optional error message or status info
    string node_id = 3;           // Responding node identifier
}

// Streaming frame carrying full request for parity with unary path
message ActivationFrame {
  ActivationRequest request = 1;  // same fields as unary request
  uint64 seq = 2;                 // per (nonce, link) monotonic sequence
  bool end_of_request = 3;        // optional: close hint
}

message StreamAck {
  string nonce = 1;
  uint64 seq = 2;
  bool accepted = 3;              // ack after enqueue to recv queue
  string message = 4;             // optional error/backpressure info
}

// Health check request
message HealthRequest {
    string requester_id = 1;      // ID of the requesting node
}

// Health check response
message HealthResponse {
    bool healthy = 1;             // Node health status
    string node_id = 2;           // Responding node ID
    repeated int32 assigned_layers = 3;  // Layers assigned to this node
    int32 queue_size = 4;         // Current queue size
    int32 active_requests = 5;    // Number of active requests being processed
}

// Weight prefetch message (for internal use)
message WeightRequest {
    string weight_id = 1;         // Weight identifier
    int32 layer_id = 2;           // Associated layer
    int32 priority = 3;           // Prefetch priority
}

message ResetCacheRequest {
}

message ResetCacheResponse {
  bool success = 1;
  string message = 2;
}

// Latency measurement request
message LatencyMeasureRequest {
  string requester_id = 1;          // ID of the requesting node
  int32 payload_size = 2;           // Size of dummy data to send (bytes)
  bytes dummy_data = 3;             // Dummy payload data
  int64 timestamp = 4;              // Timestamp when request was sent
}

// Latency measurement response
message LatencyMeasureResponse {
  bool success = 1;                 // Whether measurement succeeded
  string message = 2;               // Optional error message
  string node_id = 3;               // Responding node ID
  int64 timestamp = 4;              // Timestamp when response was sent
}
